---
import Layout from "@/layouts/Layout.astro";
import { getContent } from "@/utils/queries/content";
import ContentCard from "@/components/ContentCard.astro";

export async function getStaticPaths() {
  const contentTypes = ["achievements", "quests", "instances", "items"];
  const paths = [];

  for (const contentType of contentTypes) {
    const firstPage = await getContent(contentType, 1);
    const totalPages = firstPage.pagination.page_total;

    for (let i = 0; i < totalPages; i++) {
      paths.push({
        params: { contentType, page: (i + 1).toString() },
      });
    }
  }

  return paths;
}

export const prerender = true;

const { contentType, page } = Astro.params;
const currentPage = parseInt(page || "1");
const { results: contentItems, pagination } = await getContent(
  contentType,
  currentPage,
);

// Next page URL for infinite scroll
const nextPage = pagination.page_next
  ? `/${contentType}/${pagination.page_next}`
  : null;
---

<Layout>
  <h1 class="mb-6 text-3xl font-bold capitalize">{contentType}</h1>
  <div
    class="content-grid grid grid-cols-1 gap-4 md:grid-cols-2 lg:grid-cols-3"
  >
    {
      contentItems?.map((item) => (
        <ContentCard type={contentType} item={item} />
      ))
    }
  </div>

  {
    nextPage && (
      <div
        id="infinite-scroll-marker"
        data-next-page={nextPage}
        class="py-4 text-center"
      >
        <div class="inline-block h-8 w-8 animate-spin rounded-full border-4 border-gray-300 border-t-blue-600" />
        <p class="mt-2 text-gray-600">Loading more {contentType}...</p>
      </div>
    )
  }

  <script define:vars={{ contentType }}>
    let isLoading = false;

    function setupInfiniteScroll() {
      const marker = document.getElementById("infinite-scroll-marker");
      const contentGrid = document.querySelector(".content-grid");

      if (!marker || !contentGrid) return;

      const observer = new IntersectionObserver(
        async (entries) => {
          if (entries[0].isIntersecting && !isLoading) {
            const nextPage = marker.dataset.nextPage;
            if (!nextPage) return;

            isLoading = true;

            try {
              const response = await fetch(nextPage);
              if (!response.ok) throw new Error("Network response was not ok");

              const text = await response.text();

              const parser = new DOMParser();
              const doc = parser.parseFromString(text, "text/html");

              const newContentContainer = doc.querySelector(".content-grid");
              const newMarker = doc.getElementById("infinite-scroll-marker");

              if (newContentContainer) {
                contentGrid.innerHTML += newContentContainer.innerHTML;

                if (newMarker?.dataset.nextPage) {
                  marker.dataset.nextPage = newMarker.dataset.nextPage;
                  observer.observe(marker);

                  // Extract the page number from the next page URL
                  const pageMatch = newMarker.dataset.nextPage.match(
                    new RegExp(`/${contentType}/(\\d+)`),
                  );
                  if (pageMatch) {
                    const currentPage = pageMatch[1];

                    // Update the URL without refreshing the page
                    const newUrl = `/${contentType}/${currentPage}`;
                    window.history.replaceState(
                      { page: currentPage },
                      "",
                      newUrl,
                    );
                  }
                } else {
                  marker.remove();
                }
              }
            } catch (error) {
              console.error(`Error loading more ${contentType}:`, error);
              const errorMessage = document.createElement("div");
              errorMessage.className = "text-red-500 text-center mt-4";
              errorMessage.textContent = `Failed to load more ${contentType}. Please try again.`;
              marker.parentElement?.insertBefore(errorMessage, marker);

              setTimeout(() => {
                const errorEl = document.querySelector(".text-red-500");
                if (errorEl) errorEl.remove();
              }, 3000);
            } finally {
              isLoading = false;
            }
          }
        },
        {
          threshold: 0.1,
        },
      );

      observer.observe(marker);

      // Handle browser back/forward navigation
      window.addEventListener("popstate", (event) => {
        if (event.state?.page) {
          window.location.reload();
        }
      });
    }

    // Handle scroll position restoration
    function saveScrollPosition() {
      sessionStorage.setItem("scrollPosition", window.scrollY.toString());
    }

    function restoreScrollPosition() {
      const savedPosition = sessionStorage.getItem("scrollPosition");
      if (savedPosition) {
        window.scrollTo(0, parseInt(savedPosition));
        sessionStorage.removeItem("scrollPosition");
      }
    }

    // Initial setup
    setupInfiniteScroll();
    restoreScrollPosition();

    // Setup for view transitions
    document.addEventListener("astro:page-load", () => {
      isLoading = false;
      setupInfiniteScroll();
      restoreScrollPosition();
    });

    // Save scroll position before navigation
    document.addEventListener("astro:before-preparation", saveScrollPosition);
  </script>
</Layout>
